# Gavin Crane
# pathing.py
# This program is a pathfinding visualization program that solves mazes generated by the user.
# It shows each step of how the selected algorithm solves that maze and finds the shortest path if applicable

import pygame
import numpy as np
import random
import time
import button
import square
import dfs
import dijkstra
import generateMaze
import primsMaze
import sys


GRID_SIZE_HEIGHT = 60
GRID_SIZE_WIDTH = 42

SQUARE_WIDTH = 16

FPS = 60

WHITE = (255,255,255)
RED = (255, 0, 0)
GREEN = (13, 255, 0)
YELLOW = (0, 255, 20)
BRIGHT_YELLOW = (255, 255, 20)
BLUE = (0, 0, 128)
BLACK = (0, 0, 0)

pygame.init()

# this is for very large boards:
sys.setrecursionlimit(3000)

scr = pygame.display.set_mode((1200,700))
pygame.display.set_caption('Pygame Window')

def displayMouseLocation():
    loc = pygame.mouse.get_pos()
    text = font.render(str(loc), True, BLACK, WHITE)
    scr.blit(text, textRect)
    
def createGrid():
    print("this is the created grid \n =================================================================")
    grid = [[None] * GRID_SIZE_HEIGHT for _ in range(GRID_SIZE_WIDTH)]
    y = 10
    for i in range(GRID_SIZE_WIDTH):
        x = 10
        for j in range(GRID_SIZE_HEIGHT):
            grid[i][j] = square.Square(i, j, x, y, SQUARE_WIDTH)
            x += SQUARE_WIDTH
        y += SQUARE_WIDTH
        print()
    print("============================================================")
    return grid

# reset every node in the board
def clearBoard(grid):    
    for i in range(GRID_SIZE_WIDTH):
        for j in range(GRID_SIZE_HEIGHT):
            grid[i][j].isWall = False
            grid[i][j].isPath = False
            grid[i][j].dist = np.inf
            grid[i][j].isVisited = False
            grid[i][j].prevTile = None
            dfs.DFS.foundDest = False    
            generateMaze.MakeMaze.foundDest = False  
    pygame.display.update()
    
def clearPaths(grid):
    for i in range(GRID_SIZE_WIDTH):
        for j in range(GRID_SIZE_HEIGHT):
            grid[i][j].isPath = False
            grid[i][j].dist = np.inf
            grid[i][j].isVisited = False
            grid[i][j].prevTile = None
            dfs.DFS.foundDest = False    
            generateMaze.MakeMaze.foundDest = False  
    pygame.display.update()
            

# draw the board and check for node/tile properties and display them in the window
def displayAndUpdateGrid(grid):
      
    for i in range(GRID_SIZE_WIDTH):
        for j in range(GRID_SIZE_HEIGHT):
            
            # draw the grid
            pygame.draw.rect(scr, (0,0,0), [grid[i][j].sqx, grid[i][j].sqy, SQUARE_WIDTH, SQUARE_WIDTH]) # draw grid background
            pygame.draw.rect(scr, (255, 255, 255), [grid[i][j].sqx, grid[i][j].sqy, SQUARE_WIDTH-1, SQUARE_WIDTH-1 ]) # draw grid tiles
            
            # draw what the final path the algorithm explored
            if grid[i][j].isPath:
                pygame.draw.rect(scr, (245, 164, 66), [grid[i][j].sqx, grid[i][j].sqy, SQUARE_WIDTH-1, SQUARE_WIDTH-1])
            elif grid[i][j].isVisited:
                pygame.draw.rect(scr, (143, 126, 191), [grid[i][j].sqx, grid[i][j].sqy, SQUARE_WIDTH-1, SQUARE_WIDTH-1])
                
                #$grid[i][j].isWall = True
                #pygame.draw.rect(scr, (30, 23, 100), [grid[i][j].sqx, grid[i][j].sqy, SQUARE_WIDTH, SQUARE_WIDTH ])
                
            # draw the destination
            elif grid[i][j].isEndNode:
                pygame.draw.rect(scr, RED, [grid[i][j].sqx+5, grid[i][j].sqy+5, SQUARE_WIDTH-10, SQUARE_WIDTH-10])
            
            # draw the starting position
            elif grid[i][j].isStartNode:
                pygame.draw.rect(scr, (13, 255, 0), [grid[i][j].sqx+5, grid[i][j].sqy+5, SQUARE_WIDTH-10, SQUARE_WIDTH-10 ])
                
            # draw walls
            elif grid[i][j].isWall:
                pygame.draw.rect(scr, (0, 0, 0), [grid[i][j].sqx, grid[i][j].sqy, SQUARE_WIDTH, SQUARE_WIDTH ])
    pygame.display.update()

    
done = False

DFSButton = button.Button(WHITE, 1028, 20, 100, 50, "Depth First Search")
dijkstraButton = button.Button(WHITE, 1028, 100, 100, 50, "Dijiktra's")
optionButton3 = button.Button(WHITE, 1028, 180, 100, 50, "A*")

resetBoardButton = button.Button(WHITE, 1028 , 600, 100, 50,  "Clear Board")
drawMazeButton = button.Button(WHITE, 1028, 520, 100, 50, "Random Maze")
drawPrimsMazeButton = button.Button(WHITE, 1028 , 440, 100, 50,  "Prim's Maze") 

#create game grid
newGrid = createGrid()

font = pygame.font.Font('freesansbold.ttf', 32)
# create a text surface object,
# on which text is drawn on it.
text = font.render('GeeksForGeeks', True, RED, GREEN)
 
# create a rectangular object for the
# text surface object
textRect = text.get_rect()

textRect.center = (1100, 400)

#visualizeGrid(newGrid)

isDraggingStart = False 
isDraggingEnd = False

clock = pygame.time.Clock()

startNodeCoords = (21, 10)
endNodeCoords = (21, 49)

prevStartNodeCoords = startNodeCoords
prevEndNodeCoords = endNodeCoords

newGrid[startNodeCoords[0]][startNodeCoords[1]].isStartNode = True
newGrid[endNodeCoords[0]][endNodeCoords[1]].isEndNode = True
        
# The program loop
while not done:
    
    clock.tick(FPS)

    for event in pygame.event.get():
        r1 = random.randint(0, 10)
        
        print(r1)
        
        # This is one frame in 1/FPS milliseconds
        
        mouse_presses = pygame.mouse.get_pressed() # detect mouse presses on this frame
        
        displayAndUpdateGrid(newGrid) 

        # draw buttons
        DFSButton.draw(scr, (192, 192, 192))
        dijkstraButton.draw(scr, (192, 192, 192))
        optionButton3.draw(scr, (192, 192, 192))
        resetBoardButton.draw(scr, (192, 192, 192))
        drawMazeButton.draw(scr, (192, 192, 192))
        drawPrimsMazeButton.draw(scr, (192, 192, 192))
        
        
        # CHECK FOR USER CHANGING THE START NODE/TILE
        # dragging start to a different position
        for i in range(GRID_SIZE_WIDTH):
            for j in range(GRID_SIZE_HEIGHT):
                if newGrid[i][j].hover(pygame.mouse.get_pos(), scr) and (event.type == pygame.MOUSEBUTTONDOWN) and newGrid[i][j].isStartNode:
                    prevStartNodeCoords = (i, j)
                    newGrid[i][j].isStartNode = False
                    isDraggingStart = True
                    break
        
        # check for when the use lets go of left click, place the relocated start node/tile there if valid
        for i in range(GRID_SIZE_WIDTH):
            for j in range(GRID_SIZE_HEIGHT):
                if newGrid[i][j].hover(pygame.mouse.get_pos(), scr) and (event.type == pygame.MOUSEBUTTONUP) and isDraggingStart:
                    if not newGrid[i][j].isWall and not newGrid[i][j].isEndNode: # check for valid placement
                        isDraggingStart = False
                        newGrid[i][j].isStartNode = True
                        startNodeCoords = (i, j)
                    else: # user let go of the start node on an invalid position, revert starting node to prior position
                        newGrid[prevStartNodeCoords[0]][prevStartNodeCoords[1]].isStartNode = True
                        isDraggingStart = False
                        
        # CHECK FOR USER CHANGING THE DESTINATION
        # dragging the end/dest to a different position
        for i in range(GRID_SIZE_WIDTH):
            for j in range(GRID_SIZE_HEIGHT):
                if newGrid[i][j].hover(pygame.mouse.get_pos(), scr) and (event.type == pygame.MOUSEBUTTONDOWN) and newGrid[i][j].isEndNode:
                    prevEndNodeCoords = (i, j)
                    newGrid[i][j].isEndNode = False
                    isDraggingEnd = True
                    break
                
        # check for when the user lets go of left click, place the relocated start node/tile there if valid
        for i in range(GRID_SIZE_WIDTH):
            for j in range(GRID_SIZE_HEIGHT):
                if newGrid[i][j].hover(pygame.mouse.get_pos(), scr) and (event.type == pygame.MOUSEBUTTONUP) and isDraggingEnd:
                    if not newGrid[i][j].isWall and not newGrid[i][j].isStartNode: # check for valid placement
                        isDraggingEnd = False
                        newGrid[i][j].isEndNode = True
                        endNodeCoords = (i, j)
                    else: # user let go of the start node on an invalid position, revert starting node to prior position
                        newGrid[prevEndNodeCoords[0]][prevEndNodeCoords[1]].isEndNode = True
                        isDraggingEnd = False
      
        # anything bellow this if statement can only happen if user isnt changing the start or end locations
        if not isDraggingStart and not isDraggingEnd:
            # user drawing walls on the board    
            for i in range(GRID_SIZE_WIDTH):
                for j in range(GRID_SIZE_HEIGHT):
                    if newGrid[i][j].hover(pygame.mouse.get_pos(), scr) and (mouse_presses[0] == True) and (newGrid[i][j].isStartNode == False) and (newGrid[i][j].isEndNode == False):
                        newGrid[i][j].isWall = True
                            
        # ----execute buttons if clicked----  
            # depth first search   
            if (DFSButton.hover(pygame.mouse.get_pos(), scr)) and (event.type == pygame.MOUSEBUTTONDOWN):
                clearPaths(newGrid)
                dfs.DFS(newGrid, startNodeCoords, endNodeCoords, GRID_SIZE_HEIGHT, GRID_SIZE_WIDTH, SQUARE_WIDTH, scr)
                print("DFS!")

            #dijkstra
            if (dijkstraButton.hover(pygame.mouse.get_pos(), scr)) and (event.type == pygame.MOUSEBUTTONDOWN):
                clearPaths(newGrid)
                dijkstra.Dijkstra(newGrid, startNodeCoords, endNodeCoords, GRID_SIZE_HEIGHT, GRID_SIZE_WIDTH, SQUARE_WIDTH, scr)
                print("Dijkstra!")
                
            if (drawMazeButton.hover(pygame.mouse.get_pos(), scr)) and (event.type == pygame.MOUSEBUTTONDOWN):
                
                for i in range(GRID_SIZE_WIDTH):
                    for j in range(GRID_SIZE_HEIGHT):
                        if not newGrid[i][j].isStartNode and not newGrid[i][j].isEndNode:
                            newGrid[i][j].isWall = True

                displayAndUpdateGrid(newGrid) 
                generateMaze.MakeMaze(newGrid, startNodeCoords, endNodeCoords, SQUARE_WIDTH, scr)
                print("completely random Maze")
                
            if (drawPrimsMazeButton.hover(pygame.mouse.get_pos(), scr)) and (event.type == pygame.MOUSEBUTTONDOWN):
                
                for i in range(GRID_SIZE_WIDTH):
                    for j in range(GRID_SIZE_HEIGHT):
                        if not newGrid[i][j].isStartNode and not newGrid[i][j].isEndNode:
                            newGrid[i][j].isWall = True
                displayAndUpdateGrid(newGrid)
                primsMaze.MakePrimsMaze(newGrid, startNodeCoords, endNodeCoords, SQUARE_WIDTH, scr)
                
                
            
        if (resetBoardButton.hover(pygame.mouse.get_pos(), scr)) and (event.type == pygame.MOUSEBUTTONDOWN):
            clearBoard(newGrid)
            print("Clear Board")
            
        if event.type == pygame.QUIT:  
            done = True  
pygame.display.flip()
pygame.quit() 